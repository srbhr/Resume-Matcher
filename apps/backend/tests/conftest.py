import os
import sys
import pytest
import pytest_asyncio
import asyncio
import warnings
from pathlib import Path
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy import text

"""Global pytest fixtures and collection hooks (Neon/Postgres-only).

Tests run strictly against a Postgres/Neon database. Alembic migrations are
applied once per session to ensure schema parity, and each test runs inside a
SAVEPOINT for isolation.
"""

# Do not enable any SQLite fallbacks; backend is Neon/Postgres-only

# Silence recurring pydub ffmpeg presence RuntimeWarning in tests; it's not
# relevant to current backend concerns and creates noise.
warnings.filterwarnings(
    "ignore",
    message="Couldn't find ffmpeg or avconv",
    category=RuntimeWarning,
)

# Ensure parent directory that contains the 'app' package is on PYTHONPATH
_THIS_DIR = os.path.dirname(__file__)
_APP_PARENT = os.path.abspath(os.path.join(_THIS_DIR, '..'))  # -> apps/backend
if _APP_PARENT not in sys.path:
    sys.path.insert(0, _APP_PARENT)

from app.models import Base
from app.core.config import settings as core_settings
from app.core.database import async_engine

# ---------------------------------------------------------------------------
# Test database initialization strategy (Neon/Postgres only)
# ---------------------------------------------------------------------------
def _is_postgres(url: str) -> bool:
    return url.startswith("postgresql+") or url.startswith("postgres://")

ASYNC_DB_URL = os.getenv("ASYNC_DATABASE_URL", "").strip()
SYNC_DB_URL = os.getenv("SYNC_DATABASE_URL", "").strip()
if not (_is_postgres(ASYNC_DB_URL) and _is_postgres(SYNC_DB_URL)):
    raise RuntimeError(
        "Tests require Postgres/Neon. Set SYNC_DATABASE_URL (postgresql+psycopg://) and "
        "ASYNC_DATABASE_URL (postgresql+asyncpg://)."
    )


# Disable background tasks globally for test session to prevent event-loop closed races
os.environ.setdefault("DISABLE_BACKGROUND_TASKS", "true")

@pytest.fixture(scope="session", autouse=True)
def _bg_tasks_disabled_flag():
    os.environ["DISABLE_BACKGROUND_TASKS"] = "true"
    yield


@pytest.fixture(scope="session", autouse=True)
def _ensure_async_engine_disposed():
    """Ensure the global async_engine is disposed at end of test session.

    Helps suppress aiosqlite thread warnings (event loop closed) by disposing
    connections while loop still alive.
    """
    yield
    try:
        loop = asyncio.get_event_loop()
        if loop.is_closed():  # pragma: no cover - defensive
            return
        loop.run_until_complete(async_engine.dispose())
    except RuntimeError:
        # If no running loop / already closed, ignore.
        pass


@pytest.fixture(scope="session", autouse=True)
def _apply_alembic_migrations_once():
    """Run Alembic migrations to head once for the test session."""
    from alembic import command
    from alembic.config import Config as AlembicConfig

    ini_path = os.path.abspath(os.path.join(_APP_PARENT, 'alembic.ini'))
    cfg = AlembicConfig(ini_path)
    # Force URL directly (avoids relying on env interpolation)
    cfg.set_main_option("sqlalchemy.url", SYNC_DB_URL)
    command.upgrade(cfg, "head")


@pytest_asyncio.fixture()
async def db_session():
    """Return an isolated AsyncSession for unit tests.

    For Postgres we connect to the real test database (already migrated) and
    wrap each test in a SAVEPOINT (nested transaction) for isolation. For
    sqlite in-memory we just create a fresh engine per test.
    """
    engine = create_async_engine(ASYNC_DB_URL, future=True)
    async with engine.connect() as conn:
        trans = await conn.begin()
        SessionLocal = async_sessionmaker(bind=conn, expire_on_commit=False, class_=AsyncSession)
        async with SessionLocal() as session:
            try:
                yield session
            finally:
                await session.rollback()
        await trans.rollback()
    await engine.dispose()


def pytest_collection_modifyitems(config, items):  # type: ignore
    """Filter out parametrized trio variants generated by anyio if present.

    Some prior collection state may have added [trio] variants before our
    markers; drop them to avoid ModuleNotFoundError when trio isn't installed.
    """
    filtered = []
    for item in items:
        if item.name.endswith("[trio]"):
            continue
        filtered.append(item)
    items[:] = filtered
